
* interrupt and exception
exception: 
- ecall 
- div 0
- align memory

interrupt :
- timer
- ipi

  1. interrupt vector table *mtvec*

#+begin_src asm


	.section .entry, "ax", %progbits
	.align 3
	.globl _trap_handler
_trap_handler:
	TRAP_SAVE_AND_SETUP_SP_T0

	TRAP_SAVE_MEPC_MSTATUS 0

	TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0

	TRAP_CALL_C_ROUTINE

	TRAP_RESTORE_GENERAL_REGS_EXCEPT_SP_T0

	TRAP_RESTORE_MEPC_MSTATUS 0

	TRAP_RESTORE_SP_T0

	mret

       //......
	la	a4, _trap_handler
	csrw	CSR_MTVEC, a4
       //......
#+end_src


  2. M-mode  default (S->M, M itself, U->M) -> stack switch

#+begin_src asm

.macro	TRAP_SAVE_AND_SETUP_SP_T0
	/* Swap TP and MSCRATCH */
	csrrw	tp, CSR_MSCRATCH, tp

	/* Save T0 in scratch space */
	REG_S	t0, SBI_SCRATCH_TMP0_OFFSET(tp)

	/*
	 * Set T0 to appropriate exception stack
	 *
	 * Came_From_M_Mode = ((MSTATUS.MPP < PRV_M) ? 1 : 0) - 1;
	 * Exception_Stack = TP ^ (Came_From_M_Mode & (SP ^ TP))
	 *
	 * Came_From_M_Mode = 0    ==>    Exception_Stack = TP
	 * Came_From_M_Mode = -1   ==>    Exception_Stack = SP
	 */
	csrr	t0, CSR_MSTATUS
	srl	t0, t0, MSTATUS_MPP_SHIFT
	and	t0, t0, PRV_M
	slti	t0, t0, PRV_M // MPP 0 U-mode , MPP 1 S-mode , MPP 2 M-mode
	add	t0, t0, -1
	xor	sp, sp, tp
	and	t0, t0, sp
	xor	sp, sp, tp
	xor	t0, tp, t0

	/* Save original SP on exception stack */
	REG_S	sp, (SBI_TRAP_REGS_OFFSET(sp) - SBI_TRAP_REGS_SIZE)(t0)

	/* Set SP to exception stack and make room for trap registers */
	add	sp, t0, -(SBI_TRAP_REGS_SIZE)

	/* Restore T0 from scratch space */
	REG_L	t0, SBI_SCRATCH_TMP0_OFFSET(tp)

	/* Save T0 on stack */
	REG_S	t0, SBI_TRAP_REGS_OFFSET(t0)(sp)

	/* Swap TP and MSCRATCH */
	csrrw	tp, CSR_MSCRATCH, tp
.endm
#+end_src
[[./img/2_stack_switch.png]]
     
3. call sbi_trap_handler (c function)

Befor calling the sbi_trap_handler (c function), the stack in M-mode is just like,
[[./img/2_m-mode_trap.png]]

* sbi_ecall mechanism

** function call procedure

#+begin_src c

#define SBI_ECALL(__num, __a0, __a1, __a2)                                    \
	({                                                                    \
		register unsigned long a0 asm("a0") = (unsigned long)(__a0);  \
		register unsigned long a1 asm("a1") = (unsigned long)(__a1);  \
		register unsigned long a2 asm("a2") = (unsigned long)(__a2);  \
		register unsigned long a7 asm("a7") = (unsigned long)(__num); \
		asm volatile("ecall"                                          \
			     : "+r"(a0)                                       \
			     : "r"(a1), "r"(a2), "r"(a7)                      \
			     : "memory");                                     \
		a0;                                                           \
	})

#define SBI_ECALL_1(__num, __a0) SBI_ECALL(__num, __a0, 0, 0)
#define sbi_ecall_console_putc(c) SBI_ECALL_1(SBI_EXT_0_1_CONSOLE_PUTCHAR, (c))

static inline void sbi_ecall_console_puts(const char *str)
{
	while (str && *str)
		sbi_ecall_console_putc(*str++);
}


void test_main(unsigned long a0, unsigned long a1)
{
	sbi_ecall_console_puts("\nTest payload running\n");
	while (1)
		wfi();
}

#+end_src


** significant function called

#+begin_src c
ecall backtrace

_trap_handler
+->sbi_trap_handler
   +->sbi_ecall_handler
     +->sbi_ecall_find_extension
       +->sbi_ecall_legacy_handler
	   +->sbi_putc
#+end_src


** register
in the initialization of sbi_init, the ecall_extension will be registered, each one we say as it a extension and each one has a unique struct to point to. This function *sbi_ecall_extension_register* linked every extension struct in a linked-list, each of the instant will be initialilization before the function called. After that, when the ecall goes into the *sbi_ecall_trap_handler*, it will find the extension instant by the extid. Then it will call the handle of the extension, which is a handler to handle different funcids below the same extid. Finally it will call platform related function to answer it.

The whole procedure is just like this,
[[./img/2_sbi_ecall_extension.png]]


* interrupt delegation

